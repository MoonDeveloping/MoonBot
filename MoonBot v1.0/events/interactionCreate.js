const chalk = require('chalk');
const fs = require('node:fs');
const path = require('node:path');
// Import Discord.js components at the top of the file
const { 
    ActionRowBuilder, 
    ButtonBuilder, 
    ButtonStyle, 
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    EmbedBuilder 
} = require('discord.js');

module.exports = {
    name: 'interactionCreate',
    async execute(interaction) {
        // Slash komut i≈üleme
        if (interaction.isChatInputCommand()) {
            const command = interaction.client.commands.get(interaction.commandName);

            if (!command) {
                return;
            }

            try {
                await command.execute(interaction);
            } catch (error) {
                console.error(error);
                
                // Embed handler'ƒ± import et
                const embedHandler = require('../util/embedHandler')(interaction.client);
                
                if (interaction.replied || interaction.deferred) {
                    await interaction.followUp({ 
                        embeds: [embedHandler.errorEmbed('Hata', 'Bu komutu √ßalƒ±≈ütƒ±rƒ±rken bir hata olu≈ütu!')], 
                        ephemeral: true 
                    });
                } else {
                    await interaction.reply({ 
                        embeds: [embedHandler.errorEmbed('Hata', 'Bu komutu √ßalƒ±≈ütƒ±rƒ±rken bir hata olu≈ütu!')], 
                        ephemeral: true 
                    });
                }
            }
        }
        
        // Buton interaksiyonlarƒ±nƒ± i≈üleme
        if (interaction.isButton()) {
            // Kayƒ±t butonlarƒ± i≈üleme
            if (interaction.customId.startsWith('register_')) {
                await handleRegisterButton(interaction);
                return;
            }
            
            // Yardƒ±m men√ºs√º butonlarƒ±nƒ± i≈üleme
            if (interaction.customId === 'help_main_menu') {
                const embedHandler = require('../util/embedHandler')(interaction.client);
                const emoji = require('../util/emoji');
                
                const foldersPath = path.join(__dirname, '../commands');
                const commandFolders = fs.readdirSync(foldersPath);
                
                const categoryEmojis = {
                    admin: emoji.guard,
                    kullanƒ±cƒ±: emoji.human,         
                    sistem: emoji.settings,
                    m√ºzik: emoji.music,
                };
                
                const embed = embedHandler.infoEmbed(
                    `${emoji.search} **KOMUT YARDIM MEN√úS√ú**`,
                    `**Ho≈ü geldiniz, ${interaction.user.username}!**\n` +
                    `> Bot komutlarƒ±nƒ± kategoriler halinde g√∂r√ºnt√ºleyebilirsiniz.\n` +
                    `> Bir kategoriyi incelemek i√ßin butonlara tƒ±klayƒ±n veya \`/yardƒ±m [kategori]\` komutunu kullanƒ±n.\n\n` +
                    `\`\`\`md\n# Mevcut Kategoriler\`\`\``
                ).setFooter({ 
                    text: `${interaction.client.user.username} ‚Ä¢ Yardƒ±m Sistemi ‚Ä¢ ${interaction.client.guilds.cache.size} Sunucu`, 
                    iconURL: interaction.client.user.displayAvatarURL() 
                });
                
                // Her kategoriyi emoji ve √∂zel formatlama ile ekle
                let categoryList = "";
                commandFolders.forEach(folder => {
                    const categoryPath = path.join(foldersPath, folder);
                    const commandFiles = fs.readdirSync(categoryPath).filter(file => file.endsWith('.js'));
                    
                    const folderEmoji = categoryEmojis[folder] || 'üìÅ';
                    categoryList += `${folderEmoji} **${folder.toUpperCase()}**\n`;
                    categoryList += `> \`${commandFiles.length}\` komut bulunuyor\n\n`;
                });
                
                embed.setDescription(embed.data.description + categoryList);
                
                // Kategoriler i√ßin butonlar olu≈ütur
                const row = new ActionRowBuilder();
                
                // Her kategori i√ßin bir buton ekle (max 5 buton)
                commandFolders.slice(0, 5).forEach(folder => {
                    const folderEmoji = categoryEmojis[folder] || 'üìÅ';
                    row.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`help_category_${folder}`)
                            .setLabel(folder.charAt(0).toUpperCase() + folder.slice(1))
                            .setStyle(ButtonStyle.Success)
                            .setEmoji(folderEmoji)
                    );
                });
                
                await interaction.update({ embeds: [embed], components: [row] });
            } 
            // Kategori butonlarƒ±nƒ± i≈üleme
            else if (interaction.customId.startsWith('help_category_')) {
                const category = interaction.customId.replace('help_category_', '');
                const embedHandler = require('../util/embedHandler')(interaction.client);
                const emoji = require('../util/emoji');
                
                const foldersPath = path.join(__dirname, '../commands');
                const commandFolders = fs.readdirSync(foldersPath);
                
                if (!commandFolders.includes(category)) {
                    return interaction.update({
                        content: `**‚ö†Ô∏è Ge√ßersiz kategori!**\n> Mevcut kategoriler: \`${commandFolders.join('`, `')}\``,
                        embeds: [], 
                        components: []
                    });
                }
                
                const categoryPath = path.join(foldersPath, category);
                const commandFiles = fs.readdirSync(categoryPath).filter(file => file.endsWith('.js'));
                
                // Kategori komutlarƒ± embed'ini olu≈ütur
                const embed = embedHandler.infoEmbed(
                    `üìö **${category.toUpperCase()} KATEGORƒ∞Sƒ∞ KOMUTLARI**`,
                    `> Bu kategoride toplam **${commandFiles.length}** komut bulunuyor.\n` + 
                    `> A≈üaƒüƒ±da her komutun a√ßƒ±klamasƒ±nƒ± g√∂rebilirsiniz.\n\n` +
                    `\`\`\`md\n# ${category.charAt(0).toUpperCase() + category.slice(1)} Komutlarƒ±\`\`\``
                ).setFooter({ 
                    text: `${interaction.client.user.username} ‚Ä¢ Komut Sistemi`, 
                    iconURL: interaction.client.user.displayAvatarURL() 
                });
                
                // Her komutu g√∂steri≈üli ≈üekilde ekle
                let commandListText = "";
                for (const file of commandFiles) {
                    const filePath = path.join(categoryPath, file);
                    const command = require(filePath);
                    
                    commandListText += `**/${command.data.name}**\n`;
                    commandListText += `> \`${command.data.description}\`\n\n`;
                }
                
                embed.setDescription(embed.data.description + commandListText);
                
                // Ana men√ºye d√∂nmek i√ßin buton olu≈ütur
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('help_main_menu')
                            .setLabel('Ana Men√ºye D√∂n')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('üè†')
                    );
                
                await interaction.update({ embeds: [embed], components: [row] });
            }
            
            // Ticket butonlarƒ± i≈üleme
            if (interaction.customId === 'create_ticket') {
                await handleTicketCreation(interaction);
                return;
            }
            
            if (interaction.customId === 'close_ticket') {
                await handleTicketClose(interaction);
                return;
            }
            
            if (interaction.customId === 'delete_ticket') {
                await handleTicketDelete(interaction);
                return;
            }
            
            // √ñzel oda butonlarƒ± i≈üleme
            if (interaction.customId === 'create_private_room') {
                await handlePrivateRoomCreation(interaction);
                return;
            }
            
            if (interaction.customId.startsWith('private_room_')) {
                const [_, __, action, roomId] = interaction.customId.split('_');
                
                if (action === 'add') {
                    await handlePrivateRoomAddUser(interaction, roomId);
                    return;
                } else if (action === 'limit') {
                    await handlePrivateRoomLimit(interaction, roomId);
                    return;
                } else if (action === 'rename') {
                    await handlePrivateRoomRename(interaction, roomId);
                    return;
                } else if (action === 'close') {
                    await handlePrivateRoomClose(interaction, roomId);
                    return;
                }
            }
        }
        
        // M√ºzik aramasƒ± i√ßin String Select Menu i≈üleyicisi
        if (interaction.isStringSelectMenu() && interaction.customId.startsWith('search_')) {
            // Bu durum ara.js i√ßinde zaten i≈üleniyor
            return;
        }

        // Modal submit i≈üleme
        if (interaction.isModalSubmit()) {
            // Kayƒ±t modallarƒ± i≈üleme
            if (interaction.customId.startsWith('modal_register_')) {
                await handleRegisterModal(interaction);
                return;
            }
            
            // √ñzel oda modallarƒ± i≈üleme
            if (interaction.customId.startsWith('modal_private_room_')) {
                const parts = interaction.customId.split('_');
                const action = parts[3];
                const roomId = parts.length > 4 ? parts[4] : null;
                
                if (action === 'create') {
                    await handlePrivateRoomCreateModal(interaction);
                    return;
                } else if (action === 'add') {
                    await handlePrivateRoomAddUserModal(interaction, roomId);
                    return;
                } else if (action === 'limit') {
                    await handlePrivateRoomLimitModal(interaction, roomId);
                    return;
                } else if (action === 'rename') {
                    await handlePrivateRoomRenameModal(interaction, roomId);
                    return;
                }
            }
        }
    },
};

// Kayƒ±t butonlarƒ±nƒ± i≈üleme fonksiyonu
async function handleRegisterButton(interaction) {
    try {
        const { customId, guild, client } = interaction;
        const [action, type, userId] = customId.split('_');
        const emoji = require('../util/emoji');
        
        // √ñrnek butonlar i√ßin i≈ülem yok
        if (userId === 'example') {
            return await interaction.reply({ 
                content: 'Bu bir √∂rnek butondur ve herhangi bir i≈ülem yapmaz.', 
                ephemeral: true 
            });
        }
        
        // Kayƒ±t ayarlarƒ±nƒ± al
        const registerSettings = await getRegisterSettings(client, guild.id);
        if (!registerSettings) {
            return await interaction.reply({ 
                content: 'Kayƒ±t sistemi ayarlarƒ± bulunamadƒ±.', 
                ephemeral: true 
            });
        }
        
        // Yetkili rol√º kontrol√º
        const member = await guild.members.fetch(interaction.user.id).catch(() => null);
        if (!member || !member.roles.cache.has(registerSettings.staff_role_id)) {
            return await interaction.reply({ 
                content: `Bu i≈ülemi ger√ßekle≈ütirmek i√ßin **<@&${registerSettings.staff_role_id}>** rol√ºne sahip olmanƒ±z gerekiyor.`, 
                ephemeral: true 
            });
        }
        
        // Kayƒ±t edilecek √ºyeyi al
        const targetUser = await client.users.fetch(userId).catch(() => null);
        if (!targetUser) {
            return await interaction.reply({ 
                content: 'Kayƒ±t edilecek kullanƒ±cƒ± bulunamadƒ±.', 
                ephemeral: true 
            });
        }
        
        const targetMember = await guild.members.fetch(targetUser.id).catch(() => null);
        if (!targetMember) {
            return await interaction.reply({ 
                content: 'Kullanƒ±cƒ± sunucuda bulunamadƒ±.', 
                ephemeral: true 
            });
        }
        
        // Kayƒ±t tipi kontrol√º (erkek/kƒ±z rol√º yoksa o t√ºr se√ßilemez)
        if ((type === 'male' && !registerSettings.male_role_id) || 
            (type === 'female' && !registerSettings.female_role_id)) {
            return await interaction.reply({ 
                content: `Bu kayƒ±t t√ºr√º i√ßin gerekli rol ayarlanmamƒ±≈ü.`, 
                ephemeral: true 
            });
        }
        
        // Modal olu≈ütur
        const modal = new ModalBuilder()
            .setCustomId(`modal_register_${type}_${userId}`)
            .setTitle(
                type === 'male' ? 'Erkek √úye Kaydƒ±' : 
                type === 'female' ? 'Kƒ±z √úye Kaydƒ±' : 
                '√úye Kaydƒ±'
            );
            
        // ƒ∞sim giri≈ü alanƒ±
        const nameInput = new TextInputBuilder()
            .setCustomId('name')
            .setLabel('ƒ∞sim')
            .setPlaceholder('√úyenin ismi')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMinLength(2)
            .setMaxLength(32);
            
        // Ya≈ü giri≈ü alanƒ±
        const ageInput = new TextInputBuilder()
            .setCustomId('age')
            .setLabel('Ya≈ü')
            .setPlaceholder('√úyenin ya≈üƒ±')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMinLength(1)
            .setMaxLength(3);
            
        // Action row'larƒ± olu≈ütur
        const firstRow = new ActionRowBuilder().addComponents(nameInput);
        const secondRow = new ActionRowBuilder().addComponents(ageInput);
        
        // Modal'a action row'larƒ± ekle
        modal.addComponents(firstRow, secondRow);
        
        // Modal'ƒ± g√∂ster
        await interaction.showModal(modal);
        
    } catch (error) {
        console.error(`Kayƒ±t butonu hatasƒ±: ${error}`);
        await interaction.reply({ 
            content: 'ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu.', 
            ephemeral: true 
        });
    }
}

// Kayƒ±t modallarƒ±nƒ± i≈üleme fonksiyonu
async function handleRegisterModal(interaction) {
    try {
        const { customId, guild, client } = interaction;
        const [_, __, type, userId] = customId.split('_');
        const emoji = require('../util/emoji');
        
        // Kayƒ±t ayarlarƒ±nƒ± al
        const registerSettings = await getRegisterSettings(client, guild.id);
        if (!registerSettings) {
            return await interaction.reply({ 
                content: 'Kayƒ±t sistemi ayarlarƒ± bulunamadƒ±.', 
                ephemeral: true 
            });
        }
        
        // Log kanalƒ±nƒ± al
        const logChannel = guild.channels.cache.get(registerSettings.log_channel_id);
        if (!logChannel) {
            return await interaction.reply({ 
                content: 'Kayƒ±t log kanalƒ± bulunamadƒ±.', 
                ephemeral: true 
            });
        }
        
        // Form verilerini al
        const name = interaction.fields.getTextInputValue('name');
        const age = interaction.fields.getTextInputValue('age');
        
        // Ya≈ü kontrol√º
        if (isNaN(age) || parseInt(age) < 1 || parseInt(age) > 100) {
            return await interaction.reply({ 
                content: 'L√ºtfen ge√ßerli bir ya≈ü giriniz (1-100).', 
                ephemeral: true 
            });
        }
        
        // Yetkili rol√º kontrol√º
        const member = await guild.members.fetch(interaction.user.id).catch(() => null);
        if (!member || !member.roles.cache.has(registerSettings.staff_role_id)) {
            return await interaction.reply({ 
                content: `Bu i≈ülemi ger√ßekle≈ütirmek i√ßin **<@&${registerSettings.staff_role_id}>** rol√ºne sahip olmanƒ±z gerekiyor.`, 
                ephemeral: true 
            });
        }
        
        // Kayƒ±t edilecek √ºyeyi al
        const targetUser = await client.users.fetch(userId).catch(() => null);
        if (!targetUser) {
            return await interaction.reply({ 
                content: 'Kayƒ±t edilecek kullanƒ±cƒ± bulunamadƒ±.', 
                ephemeral: true 
            });
        }
        
        const targetMember = await guild.members.fetch(targetUser.id).catch(() => null);
        if (!targetMember) {
            return await interaction.reply({ 
                content: 'Kullanƒ±cƒ± sunucuda bulunamadƒ±.', 
                ephemeral: true 
            });
        }
        
        // Verilecek rolleri belirle
        const rolesToAdd = [];
        rolesToAdd.push(registerSettings.member_role_id);
        
        let roleDesc = "√úye";
        if (type === 'male' && registerSettings.male_role_id) {
            rolesToAdd.push(registerSettings.male_role_id);
            roleDesc = "Erkek";
        } else if (type === 'female' && registerSettings.female_role_id) {
            rolesToAdd.push(registerSettings.female_role_id);
            roleDesc = "Kƒ±z";
        }
        
        // Kullanƒ±cƒ±ya rolleri ver ve ismini deƒüi≈ütir
        try {
            // T√ºm eski rolleri temizle (except roles with ADMINISTRATOR permission)
            const rolesToRemove = targetMember.roles.cache.filter(role => 
                role.id !== guild.id && !role.permissions.has('Administrator')).map(role => role.id);
            
            if (rolesToRemove.length > 0) {
                await targetMember.roles.remove(rolesToRemove);
            }
            
            // Yeni rolleri ekle
            await targetMember.roles.add(rolesToAdd);
            
            // ƒ∞smi deƒüi≈ütir - "ƒ∞sim | Ya≈ü" formatƒ±nda
            const newNickname = `${name} | ${age}`;
            if (newNickname.length <= 32) { // Discord nickname limit
                await targetMember.setNickname(newNickname);
            }
            
            // Kullanƒ±cƒ±ya bilgilendirme mesajƒ± g√∂nder
            const embedHandler = require('../util/embedHandler')(client);
            const embed = embedHandler.successEmbed(
                `${emoji.done || '‚úÖ'} Kayƒ±t Tamamlandƒ±!`,
                `**${targetUser.tag}** kullanƒ±cƒ±sƒ± ba≈üarƒ±yla kayƒ±t edildi.\n\n` +
                `**ƒ∞sim:** ${name}\n` +
                `**Ya≈ü:** ${age}\n` +
                `**T√ºr:** ${roleDesc}\n\n` +
                `Kayƒ±t i≈üleminiz tamamlandƒ±. ƒ∞yi eƒülenceler dileriz!`
            );
            
            // Kayƒ±t log mesajƒ±
            const logEmbed = embedHandler.infoEmbed(
                `${emoji.archive || 'üìù'} Kayƒ±t ƒ∞≈ülemi Yapƒ±ldƒ±`,
                `**Kaydedilen Kullanƒ±cƒ±:** ${targetUser} (${targetUser.tag})\n` +
                `**Kaydeden Yetkili:** ${interaction.user} (${interaction.user.tag})\n` +
                `**ƒ∞sim:** ${name}\n` +
                `**Ya≈ü:** ${age}\n` +
                `**T√ºr:** ${roleDesc}\n\n` +
                `${new Date().toLocaleString('tr-TR')}`
            )
            .setThumbnail(targetUser.displayAvatarURL())
            .setFooter({ text: `Kullanƒ±cƒ± ID: ${targetUser.id} ‚Ä¢ Yetkili ID: ${interaction.user.id}` });
            
            // Log kanalƒ±na mesajƒ± g√∂nder
            await logChannel.send({ embeds: [logEmbed] });
            
            // Etkile≈üime cevap ver
            return await interaction.reply({ 
                embeds: [embed], 
                ephemeral: false 
            });
        } catch (error) {
            console.error(`Kayƒ±t i≈ülemi hatasƒ±: ${error}`);
            return await interaction.reply({ 
                content: `Kayƒ±t i≈ülemi sƒ±rasƒ±nda bir hata olu≈ütu: ${error.message}`, 
                ephemeral: true 
            });
        }
    } catch (error) {
        console.error(`Kayƒ±t modal i≈üleme hatasƒ±: ${error}`);
        
        // Eƒüer interaction hen√ºz yanƒ±tlanmadƒ±ysa
        if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
                content: 'ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu.', 
                ephemeral: true 
            });
        } else {
            await interaction.followUp({ 
                content: 'ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu.', 
                ephemeral: true 
            });
        }
    }
}

// Kayƒ±t ayarlarƒ±nƒ± getiren fonksiyon
async function getRegisterSettings(client, guildId) {
    try {
        const { database_type } = require('../config.json');
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        let registerSettings = null;
        
        if (useMySQL) {
            try {
                const results = await client.db.select('register_settings', { guild_id: guildId });
                if (results && results.length > 0) {
                    registerSettings = results[0];
                }
            } catch (err) {
                console.error(global.hata(`Kayƒ±t ayarlarƒ± alƒ±nƒ±rken MySQL hatasƒ±: ${err.message}`));
            }
        } else {
            // Sadece MySQL aktif DEƒûƒ∞LSE yerel veritabanƒ±nƒ± kullan
            const staffRoleId = client.localDB.getData("register_settings", `staff_role_id_${guildId}`);
            
            if (staffRoleId) {
                registerSettings = {
                    staff_role_id: staffRoleId,
                    register_channel_id: client.localDB.getData("register_settings", `register_channel_id_${guildId}`),
                    log_channel_id: client.localDB.getData("register_settings", `log_channel_id_${guildId}`),
                    member_role_id: client.localDB.getData("register_settings", `member_role_id_${guildId}`),
                    male_role_id: client.localDB.getData("register_settings", `male_role_id_${guildId}`),
                    female_role_id: client.localDB.getData("register_settings", `female_role_id_${guildId}`)
                };
            }
        }
        
        return registerSettings;
    } catch (error) {
        console.error(global.hata(`Kayƒ±t ayarlarƒ± alƒ±nƒ±rken hata: ${error.message}`));
        return null;
    }
}

// Ticket olu≈üturma i≈üleme fonksiyonu
async function handleTicketCreation(interaction) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Veritabanƒ± kullanƒ±labilirliƒüini kontrol et
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        // Ticket ayarlarƒ±nƒ± al
        let settings;
            
        if (useMySQL) {
            const result = await client.db.select('ticket_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("ticket_settings", `ticket.${guildID}.settings`);
        }
        
        if (!settings) {
            return interaction.reply({ 
                content: '‚ùå Ticket sistemi d√ºzg√ºn yapƒ±landƒ±rƒ±lmamƒ±≈ü. L√ºtfen bir y√∂neticiye bildirin.', 
                ephemeral: true 
            });
        }
        
        // MySQL ve LocalDB i√ßin ortak veri yapƒ±sƒ± olu≈ütur
        const categoryId = useMySQL ? settings.category_id : settings.categoryId;
        const staffRoleId = useMySQL ? settings.staff_role_id : settings.staffRoleId;
        const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
        const welcomeMessage = settings.welcomeMessage || settings.welcome_message;
        const embedColor = settings.embedColor || settings.embed_color;
        
        // Kullanƒ±cƒ±nƒ±n zaten aktif bir ticket'ƒ± var mƒ± kontrol et
        let existingTicket;
        
        if (useMySQL) {
            const tickets = await client.db.select('tickets', { guild_id: guildID, user_id: user.id, status: 'open' });
            existingTicket = tickets && tickets.length > 0;
        } else {
            // localDBHandler.hasOpenTicket fonksiyonu olmadƒ±ƒüƒ± i√ßin doƒürudan kontrol edelim
            const tickets = await localDBHandler.getData("ticket_settings", `ticket.${guildID}.tickets`) || {};
            existingTicket = Object.values(tickets).some(
                ticket => ticket.userId === user.id && ticket.status === 'open'
            );
        }
        
        if (existingTicket) {
            return interaction.reply({ 
                content: '‚ùå Zaten aktif bir ticket\'ƒ±nƒ±z bulunuyor!', 
                ephemeral: true 
            });
        }
        
        // Ticket kanalƒ± olu≈ütur
        const category = guild.channels.cache.get(categoryId);
        if (!category) {
            return interaction.reply({ 
                content: '‚ùå Ticket kategorisi bulunamadƒ±. L√ºtfen bir y√∂neticiye bildirin.', 
                ephemeral: true 
            });
        }
        
        // Ticket adƒ±nƒ± olu≈ütur
        let ticketCount;
        if (useMySQL) {
            // En son ticket numarasƒ±nƒ± bul
            const result = await client.db.query('SELECT MAX(ticket_number) as lastNumber FROM tickets WHERE guild_id = ?', [guildID]);
            const lastNumber = result && result.length > 0 && result[0].lastNumber ? result[0].lastNumber : 0;
            
            ticketCount = lastNumber + 1;
        } else {
            // incrementTicketNumber fonksiyonu olmadƒ±ƒüƒ± i√ßin doƒürudan yapalƒ±m
            let nextNumber = await localDBHandler.getData("ticket_settings", `ticket.${guildID}.nextTicketNumber`) || 1;
            await localDBHandler.insertData("ticket_settings", `ticket.${guildID}.nextTicketNumber`, nextNumber + 1);
            ticketCount = nextNumber;
        }
        
        // Kanal izinleri ayarla
        const channelPermissions = [
            {
                id: guild.roles.everyone.id,
                deny: ['ViewChannel']
            },
            {
                id: staffRoleId,
                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']
            },
            {
                id: user.id,
                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']
            },
            {
                id: guild.members.me.id,
                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'ManageChannels', 'EmbedLinks']
            }
        ];
        
        // Kanalƒ± olu≈ütur
        const ticketChannel = await guild.channels.create({
            name: `ticket-${ticketCount}`,
            type: 0, // Text Channel
            parent: categoryId,
            permissionOverwrites: channelPermissions,
            reason: `${user.tag} tarafƒ±ndan ticket olu≈üturuldu`
        });
        
        // Ticket verilerini kaydet
        const ticketData = {
            channelId: ticketChannel.id,
            userId: user.id,
            ticketNumber: ticketCount,
            createdAt: new Date().toISOString(),
            status: 'open'
        };
        
        if (useMySQL) {
            // ISO datetime formatƒ±nƒ± MySQL formatƒ±na d√∂n√º≈üt√ºr
            const createdAtMySQLFormat = new Date().toISOString().slice(0, 19).replace('T', ' ');
            
            await client.db.query(
                'INSERT INTO tickets (guild_id, channel_id, user_id, ticket_number, created_at, status) VALUES (?, ?, ?, ?, ?, ?)',
                [guildID, ticketChannel.id, user.id, ticketCount, createdAtMySQLFormat, 'open']
            );
        } else {
            await localDBHandler.insertData("tickets", `ticket.${guildID}.tickets.${ticketChannel.id}`, ticketData);
        }
        
        // Butonlarƒ± olu≈ütur
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('close_ticket')
                    .setLabel('Ticket\'ƒ± Kapat')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji(emoji.lock)
            );
            
        // Kar≈üƒ±lama mesajƒ± g√∂nder
        await ticketChannel.send({
            content: `<@${user.id}> | <@&${staffRoleId}>`,
            embeds: [{
                title: `${emoji.ticket || 'üé´'} Ticket #${ticketCount}`,
                description: welcomeMessage,
                color: embedColor ? parseInt(embedColor.replace('#', ''), 16) : 0x5768ea,
                footer: {
                    text: `${guild.name} ‚Ä¢ Ticket Sistemi`,
                    icon_url: guild.iconURL({ dynamic: true })
                },
                timestamp: new Date()
            }],
            components: [row]
        });
        
        // Log kanalƒ±na bildir
        const logChannel = guild.channels.cache.get(logChannelId);
        if (logChannel) {
            logChannel.send({
                embeds: [{
                    title: 'üé´ Yeni Ticket Olu≈üturuldu',
                    description: `**Ticket:** ${ticketChannel}\n**Kullanƒ±cƒ±:** ${user} (${user.tag})`,
                    color: 0x5768ea,
                    footer: {
                        text: `Ticket #${ticketCount}`,
                        icon_url: guild.iconURL({ dynamic: true })
                    },
                    timestamp: new Date()
                }]
            });
        }
        
        // Kullanƒ±cƒ±ya bildir
        return interaction.reply({ 
            content: `${emoji.done2} Ticket'ƒ±nƒ±z olu≈üturuldu: ${ticketChannel}`, 
            ephemeral: true 
        });
        
    } catch (error) {
        console.error(global.hata(`Ticket olu≈üturma hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed} Ticket olu≈üturulurken bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// Ticket kapatma i≈üleme fonksiyonu
async function handleTicketClose(interaction) {
    try {
        const { client, guild, channel, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Veritabanƒ± kullanƒ±labilirliƒüini kontrol et
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        // Ticket verilerini kontrol et
        let ticketData;
        
        if (useMySQL) {
            const result = await client.db.select('tickets', { guild_id: guildID, channel_id: channel.id });
            ticketData = result && result.length > 0 ? result[0] : null;
        } else {
            // getTicketData fonksiyonu olmadƒ±ƒüƒ± i√ßin doƒürudan alalƒ±m
            ticketData = await localDBHandler.getData("tickets", `ticket.${guildID}.tickets.${channel.id}`);
        }
        
        if (!ticketData) {
            return interaction.reply({ 
                content: `${emoji.closed} Bu kanal bir ticket deƒüil veya veritabanƒ±nda bulunamadƒ±.`, 
                ephemeral: true 
            });
        }
        
        // Ticket ayarlarƒ±nƒ± al
        let settings;
            
        if (useMySQL) {
            const result = await client.db.select('ticket_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("ticket_settings", `ticket.${guildID}.settings`);
        }
        
        // Ticket'ƒ± kapatƒ±lmƒ±≈ü olarak i≈üaretle
        if (useMySQL) {
            // ISO datetime formatƒ±nƒ± MySQL formatƒ±na d√∂n√º≈üt√ºr
            const closedAtMySQLFormat = new Date().toISOString().slice(0, 19).replace('T', ' ');
            
            await client.db.query(
                'UPDATE tickets SET status = ?, closed_by = ?, closed_at = ? WHERE guild_id = ? AND channel_id = ?',
                ['closed', user.id, closedAtMySQLFormat, guildID, channel.id]
            );
        } else {
            ticketData.status = 'closed';
            ticketData.closedBy = user.id;
            ticketData.closedAt = new Date().toISOString();
            await localDBHandler.insertData("tickets", `ticket.${guildID}.tickets.${channel.id}`, ticketData);
        }
        
        // Ticket kanalƒ±nƒ±n izinlerini g√ºncelle
        const ticketOwner = ticketData.userId || ticketData.user_id;
        await channel.permissionOverwrites.edit(ticketOwner, { SendMessages: false });
        
        // Butonlarƒ± g√ºncelle
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('delete_ticket')
                    .setLabel('Ticket\'ƒ± Sil')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji(emoji.trash)
            );
            
        // Kapatma mesajƒ± g√∂nder
        await interaction.reply({
            embeds: [{
                title: `${emoji.lock} Ticket Kapatƒ±ldƒ±`,
                description: `Bu ticket ${user} tarafƒ±ndan kapatƒ±lmƒ±≈ütƒ±r.\n\nTicket'ƒ± tamamen silmek i√ßin a≈üaƒüƒ±daki butonu kullanabilirsiniz.`,
                color: 0xED4245,
                timestamp: new Date()
            }],
            components: [row]
        });
        
        // Log kanalƒ±na bildir
        if (settings) {
            const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
            const logChannel = guild.channels.cache.get(logChannelId);
            if (logChannel) {
                logChannel.send({
                    embeds: [{
                        title: `${emoji.lock} Ticket Kapatƒ±ldƒ±`,
                        description: `**Ticket:** ${channel.name}\n**Kapatan:** ${user} (${user.tag})\n**Ticket Sahibi:** <@${ticketOwner}>`,
                        color: 0xED4245,
                        footer: {
                            text: `Ticket #${ticketData.ticketNumber || ticketData.ticket_number}`,
                            icon_url: guild.iconURL({ dynamic: true })
                        },
                        timestamp: new Date()
                    }]
                });
            }
        }
    } catch (error) {
        console.error(global.hata(`Ticket kapatma hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.close} Ticket kapatƒ±lƒ±rken bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// Ticket silme i≈üleme fonksiyonu
async function handleTicketDelete(interaction) {
    try {
        const { client, guild, channel, user } = interaction;
        const guildID = guild.id;
        const { database_type } = require('../config.json');
        const emoji = require('../util/emoji');
        const localDBHandler = require('../util/localDBHandler');
        
        // Veritabanƒ± kullanƒ±labilirliƒüini kontrol et
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        // Ticket verilerini kontrol et
        let ticketData;
        
        if (useMySQL) {
            const result = await client.db.select('tickets', { guild_id: guildID, channel_id: channel.id });
            ticketData = result && result.length > 0 ? result[0] : null;
        } else {
            ticketData = await localDBHandler.getData("tickets", `ticket.${guildID}.tickets.${channel.id}`);
        }
        
        if (!ticketData) {
            return interaction.reply({ 
                content: `${emoji.close} Bu kanal bir ticket deƒüil veya veritabanƒ±nda bulunamadƒ±.`, 
                ephemeral: true 
            });
        }
        
        // Ticket'ƒ±n durumunu kontrol et
        const ticketStatus = useMySQL ? ticketData.status : ticketData.status;
        
        if (ticketStatus !== 'closed') {
            return interaction.reply({ 
                content: `${emoji.close} Bu ticket hen√ºz kapatƒ±lmamƒ±≈ü! √ñnce kapatmanƒ±z gerekiyor.`, 
                ephemeral: true 
            });
        }
        
        // Ticket ayarlarƒ±nƒ± al
        let settings;
            
        if (useMySQL) {
            const result = await client.db.select('ticket_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("ticket_settings", `ticket.${guildID}.settings`);
        }
        
        // Log kanalƒ±nƒ± bul
        let logChannel;
        if (settings) {
            const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
            logChannel = guild.channels.cache.get(logChannelId);
        }
        
        // Silme bilgisini g√ºncelle
        if (useMySQL) {
            // ISO datetime formatƒ±nƒ± MySQL formatƒ±na d√∂n√º≈üt√ºr
            const deletedAtMySQLFormat = new Date().toISOString().slice(0, 19).replace('T', ' ');
            
            await client.db.query(
                'DELETE FROM tickets WHERE guild_id = ? AND channel_id = ?',
                [guildID, channel.id]
            );
        } else {
            ticketData.status = 'deleted';
            ticketData.deletedBy = user.id;
            ticketData.deletedAt = new Date().toISOString();
            await localDBHandler.deleteData("tickets", `ticket.${guildID}.tickets.${channel.id}`, ticketData);
        }
        
        // Log kanalƒ±na bildir
        if (logChannel) {
            const ticketOwner = ticketData.userId || ticketData.user_id;
            const ticketNumber = ticketData.ticketNumber || ticketData.ticket_number;
            
            await logChannel.send({
                embeds: [{
                    title: `${emoji.trash} Ticket Silindi`,
                    description: `**Ticket:** ${channel.name}\n**Silen:** ${user} (${user.tag})\n**Ticket Sahibi:** <@${ticketOwner}>`,
                    color: 0xED4245,
                    footer: {
                        text: `Ticket #${ticketNumber}`,
                        icon_url: guild.iconURL({ dynamic: true })
                    },
                    timestamp: new Date()
                }]
            });
        }
        
        // Kullanƒ±cƒ±ya bildir ve kanalƒ± sil
        await interaction.reply({ content: `${emoji.done2} Ticket silinecek...` });
        
        // 5 saniye bekle ve kanalƒ± sil
        setTimeout(async () => {
            try {
                await channel.delete(`Ticket ${user.tag} tarafƒ±ndan silindi`);
            } catch (error) {
                console.error(global.hata(`Ticket kanal silme hatasƒ±: ${error}`));
                // Kanal zaten silinmi≈ü olabilir, bu hatayƒ± g√∂rmezden gel
            }
        }, 5000);
        
    } catch (error) {
        console.error(global.hata(`Ticket silme hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: '‚ùå Ticket silinirken bir hata olu≈ütu!', 
            ephemeral: true 
        });
    }
}

// √ñzel oda olu≈üturma butonu i≈üleme
async function handlePrivateRoomCreation(interaction) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Veritabanƒ± kullanƒ±labilirliƒüini kontrol et
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        // √ñzel oda ayarlarƒ±nƒ± al
        let settings;
            
        if (useMySQL) {
            const result = await client.db.select('private_room_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("private_room_settings", `privateRoom.${guildID}.settings`);
        }
        
        if (!settings) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} √ñzel oda sistemi d√ºzg√ºn yapƒ±landƒ±rƒ±lmamƒ±≈ü. L√ºtfen bir y√∂neticiye bildirin.`, 
                ephemeral: true 
            });
        }
        
        // MySQL ve LocalDB i√ßin ortak veri yapƒ±sƒ± olu≈ütur
        const categoryId = useMySQL ? settings.category_id : settings.categoryId;
        const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
        const maxRooms = useMySQL ? settings.max_rooms_per_user : settings.maxRoomsPerUser;
        
        // Kullanƒ±cƒ±nƒ±n ka√ß odasƒ± var kontrol et
        let userRoomsCount = 0;
        
        if (useMySQL) {
            const result = await client.db.query('SELECT COUNT(*) as count FROM private_rooms WHERE guild_id = ? AND owner_id = ? AND status = ?', 
                [guildID, user.id, 'active']);
                
            userRoomsCount = result && result.length > 0 ? result[0].count : 0;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            userRoomsCount = Object.values(rooms).filter(room => 
                room.ownerId === user.id && room.status === 'active'
            ).length;
        }
        
        if (userRoomsCount >= maxRooms) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Maksimum oda sayƒ±sƒ±na ula≈ütƒ±nƒ±z! En fazla ${maxRooms} √∂zel odanƒ±z olabilir.`, 
                ephemeral: true 
            });
        }
        
        // Modal olu≈ütur
        const modal = new ModalBuilder()
            .setCustomId('modal_private_room_create')
            .setTitle('√ñzel Oda Olu≈üturma');
            
        // Oda ismi giri≈ü alanƒ±
        const nameInput = new TextInputBuilder()
            .setCustomId('room_name')
            .setLabel('Oda ƒ∞smi')
            .setPlaceholder('Oda isminizi girin (√ñrn: Sohbet Odasƒ±)')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMinLength(2)
            .setMaxLength(32);
            
        // Kullanƒ±cƒ± limiti giri≈ü alanƒ±
        const limitInput = new TextInputBuilder()
            .setCustomId('user_limit')
            .setLabel('Kullanƒ±cƒ± Limiti')
            .setPlaceholder('Maksimum ka√ß ki≈üi girebilir? (0-99, 0 = limitsiz)')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMinLength(1)
            .setMaxLength(2);
            
        // Action row'larƒ± olu≈ütur
        const firstRow = new ActionRowBuilder().addComponents(nameInput);
        const secondRow = new ActionRowBuilder().addComponents(limitInput);
        
        // Modal'a action row'larƒ± ekle
        modal.addComponents(firstRow, secondRow);
        
        // Modal'ƒ± g√∂ster
        await interaction.showModal(modal);
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda olu≈üturma hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: '‚ùå √ñzel oda olu≈üturulurken bir hata olu≈ütu!', 
            ephemeral: true 
        });
    }
}

// √ñzel oda olu≈üturma modal i≈üleme
async function handlePrivateRoomCreateModal(interaction) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Form verilerini al
        const roomName = interaction.fields.getTextInputValue('room_name');
        const userLimit = parseInt(interaction.fields.getTextInputValue('user_limit'));
        
        // Limit kontrol√º
        if (isNaN(userLimit) || userLimit < 0 || userLimit > 99) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Ge√ßersiz kullanƒ±cƒ± limiti! 0 ile 99 arasƒ±nda bir sayƒ± girmelisiniz (0 = limitsiz).`, 
                ephemeral: true 
            });
        }
        
        // Veritabanƒ± kullanƒ±labilirliƒüini kontrol et
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        // √ñzel oda ayarlarƒ±nƒ± al
        let settings;
            
        if (useMySQL) {
            const result = await client.db.select('private_room_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("private_room_settings", `privateRoom.${guildID}.settings`);
        }
        
        if (!settings) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} √ñzel oda sistemi d√ºzg√ºn yapƒ±landƒ±rƒ±lmamƒ±≈ü. L√ºtfen bir y√∂neticiye bildirin.`, 
                ephemeral: true 
            });
        }
        
        // MySQL ve LocalDB i√ßin ortak veri yapƒ±sƒ± olu≈ütur
        const categoryId = useMySQL ? settings.category_id : settings.categoryId;
        const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
        
        // Kanal izinleri ayarla
        const channelPermissions = [
            {
                id: guild.roles.everyone.id,
                deny: ['ViewChannel', 'Connect']
            },
            {
                id: user.id,
                allow: ['ViewChannel', 'Connect', 'Speak', 'Stream', 'UseVAD', 'PrioritySpeaker', 'MuteMembers', 'DeafenMembers', 'MoveMembers']
            },
            {
                id: guild.members.me.id,
                allow: ['ViewChannel', 'Connect', 'Speak', 'Stream', 'UseVAD', 'ManageChannels', 'ManageRoles']
            }
        ];
        
        // Odayƒ± olu≈ütur
        const voiceChannel = await guild.channels.create({
            name: roomName,
            type: 2, // Voice Channel
            parent: categoryId,
            userLimit: userLimit,
            permissionOverwrites: channelPermissions,
            reason: `${user.tag} tarafƒ±ndan √∂zel oda olu≈üturuldu`
        });
        
        // Oda ID'sini ve kullanƒ±cƒ± limiti veritabanƒ±na kaydet
        const roomId = voiceChannel.id;
        const createdAt = new Date();
        
        if (useMySQL) {
            // ISO datetime formatƒ±nƒ± MySQL formatƒ±na d√∂n√º≈üt√ºr
            const createdAtMySQLFormat = createdAt.toISOString().slice(0, 19).replace('T', ' ');
            
            await client.db.query(
                'INSERT INTO private_rooms (guild_id, channel_id, owner_id, room_name, user_limit, created_at, status) VALUES (?, ?, ?, ?, ?, ?, ?)',
                [guildID, roomId, user.id, roomName, userLimit, createdAtMySQLFormat, 'active']
            );
        } else {
            const roomData = {
                channelId: roomId,
                ownerId: user.id,
                roomName: roomName,
                userLimit: userLimit,
                createdAt: createdAt.toISOString(),
                status: 'active'
            };
            
            // Odalar i√ßin veri yapƒ±sƒ± var mƒ± kontrol et
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            rooms[roomId] = roomData;
            await localDBHandler.insertData("private_rooms", `privateRoom.${guildID}.rooms`, rooms);
        }
        
        // Odanƒ±n kontrol panelini olu≈ütur
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`private_room_add_${roomId}`)
                    .setLabel('Kullanƒ±cƒ± Ekle/Sil')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji(emoji.userPlus || 'üë•'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_limit_${roomId}`)
                    .setLabel('Oda Sƒ±nƒ±rƒ± Ayarla')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji(emoji.gear || '‚öôÔ∏è'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_rename_${roomId}`)
                    .setLabel('Oda ƒ∞smini Deƒüi≈ütir')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji(emoji.edit || '‚úèÔ∏è'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_close_${roomId}`)
                    .setLabel('Odayƒ± Kapat')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji(emoji.trash || 'üóëÔ∏è')
            );
        
        // Odayƒ± olu≈üturan kullanƒ±cƒ±ya bilgi mesajƒ±
        const embedColor = useMySQL ? settings.embed_color : settings.embedColor;
        
        const embed = new EmbedBuilder()
            .setTitle(`${emoji.door || 'üö™'} √ñzel Odanƒ±z Olu≈üturuldu!`)
            .setDescription(`## ${roomName}\n\nOdanƒ±zƒ± kontrol etmek i√ßin a≈üaƒüƒ±daki butonlarƒ± kullanabilirsiniz:
            
- **Kullanƒ±cƒ± Ekle/Sil**: Odanƒ±za √∂zel olarak kullanƒ±cƒ± ekleyin veya √ßƒ±karƒ±n
- **Oda Sƒ±nƒ±rƒ± Ayarla**: Odanƒ±za maksimum ka√ß ki≈üi girebileceƒüini belirleyin
- **Oda ƒ∞smini Deƒüi≈ütir**: Odanƒ±zƒ±n ismini istediƒüiniz gibi deƒüi≈ütirin
- **Odayƒ± Kapat**: Odanƒ±zƒ± kalƒ±cƒ± olarak silin`)
            .setColor(embedColor ? parseInt(embedColor.replace('#', ''), 16) : 0x5768ea)
            .setFooter({
                text: `${guild.name} ‚Ä¢ √ñzel Oda Sistemi`,
                iconURL: guild.iconURL({ dynamic: true })
            })
            .setTimestamp();
        
        // √ñnce kullanƒ±cƒ±nƒ±n DM'sine g√∂ndermeyi dene
        await interaction.reply({ 
            embeds: [embed],
            components: [row],
            ephemeral: true 
        });
        
        
        // Log kanalƒ±na bilgi mesajƒ±
        const logChannel = guild.channels.cache.get(logChannelId);
        if (logChannel) {
            logChannel.send({
                embeds: [{
                    title: `${emoji.door || 'üö™'} Yeni √ñzel Oda Olu≈üturuldu`,
                    description: `**Oda:** ${voiceChannel}\n**Sahibi:** ${user} (${user.tag})\n**Kullanƒ±cƒ± Limiti:** ${userLimit === 0 ? 'Limitsiz' : userLimit}`,
                    color: embedColor ? parseInt(embedColor.replace('#', ''), 16) : 0x5768ea,
                    footer: {
                        text: `Oda ID: ${roomId}`,
                        icon_url: guild.iconURL({ dynamic: true })
                    },
                    timestamp: new Date()
                }]
            });
        }
    } catch (error) {
        console.error(global.hata(`√ñzel oda olu≈üturma i≈üleme hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `‚ùå √ñzel oda olu≈üturulurken bir hata olu≈ütu: ${error.message}`,
            ephemeral: true 
        });
    }
}

// Oda ismini deƒüi≈ütirme butonu i≈üleme
async function handlePrivateRoomRename(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Oda bilgisini veritabanƒ±ndan al
        let roomData;
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            const result = await client.db.select('private_rooms', { 
                guild_id: guildID, 
                channel_id: roomId,
                status: 'active'
            });
            roomData = result && result.length > 0 ? result[0] : null;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            roomData = rooms[roomId];
        }
        
        if (!roomData) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu oda bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Kullanƒ±cƒ± oda sahibi mi kontrol et
        const ownerId = useMySQL ? roomData.owner_id : roomData.ownerId;
        
        if (user.id !== ownerId) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu odanƒ±n sahibi siz deƒüilsiniz!`, 
                ephemeral: true 
            });
        }
        
        // Modal olu≈ütur
        const modal = new ModalBuilder()
            .setCustomId(`modal_private_room_rename_${roomId}`)
            .setTitle('Oda ƒ∞smini Deƒüi≈ütir');
            
        // ƒ∞sim giri≈ü alanƒ±
        const nameInput = new TextInputBuilder()
            .setCustomId('room_name')
            .setLabel('Yeni Oda ƒ∞smi')
            .setPlaceholder('Odanƒ±zƒ±n yeni ismini girin')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMinLength(2)
            .setMaxLength(32);
            
        // Action row olu≈ütur
        const firstRow = new ActionRowBuilder().addComponents(nameInput);
        
        // Modal'a action row'u ekle
        modal.addComponents(firstRow);
        
        // Modal'ƒ± g√∂ster
        await interaction.showModal(modal);
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda isim deƒüi≈ütirme hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// Oda ismi deƒüi≈ütirme modal i≈üleme
async function handlePrivateRoomRenameModal(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Form verilerini al
        const newRoomName = interaction.fields.getTextInputValue('room_name');
        
        // Kanalƒ± kontrol et
        const channel = guild.channels.cache.get(roomId);
        if (!channel) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu kanal bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Oda ismini g√ºncelle
        await channel.edit({
            name: newRoomName
        });
        
        // Veritabanƒ± bilgilerini g√ºncelle
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            await client.db.query(
                'UPDATE private_rooms SET room_name = ? WHERE guild_id = ? AND channel_id = ?',
                [newRoomName, guildID, roomId]
            );
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            if (rooms[roomId]) {
                rooms[roomId].roomName = newRoomName;
                await localDBHandler.insertData("private_rooms", `privateRoom.${guildID}.rooms`, rooms);
            }
        }
        
        return interaction.reply({ 
            content: `${emoji.done2 || '‚úÖ'} √ñzel odanƒ±zƒ±n ismi ba≈üarƒ±yla "${newRoomName}" olarak deƒüi≈ütirildi!`, 
            ephemeral: true 
        });
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda isim deƒüi≈ütirme modal hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// Odayƒ± kapatma butonu i≈üleme
async function handlePrivateRoomClose(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Oda bilgisini veritabanƒ±ndan al
        let roomData;
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            const result = await client.db.select('private_rooms', { 
                guild_id: guildID, 
                channel_id: roomId,
                status: 'active'
            });
            roomData = result && result.length > 0 ? result[0] : null;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            roomData = rooms[roomId];
        }
        
        if (!roomData) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu oda bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Kullanƒ±cƒ± oda sahibi mi kontrol et
        const ownerId = useMySQL ? roomData.owner_id : roomData.ownerId;
        
        if (user.id !== ownerId && !interaction.member.permissions.has('Administrator')) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu odayƒ± kapatmak i√ßin oda sahibi veya y√∂netici olmanƒ±z gerekiyor!`, 
                ephemeral: true 
            });
        }
        
        // Kanalƒ± kontrol et
        const channel = guild.channels.cache.get(roomId);
        if (!channel) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu kanal bulunamadƒ± veya zaten silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // √ñzel oda ayarlarƒ±nƒ± al
        let settings;
        if (useMySQL) {
            const result = await client.db.select('private_room_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("private_room_settings", `privateRoom.${guildID}.settings`);
        }
        
        // Log kanalƒ±nƒ± bul
        let logChannel;
        if (settings) {
            const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
            logChannel = guild.channels.cache.get(logChannelId);
        }
        
        // Veritabanƒ± bilgilerini g√ºncelle
        if (useMySQL) {
            // ISO datetime formatƒ±nƒ± MySQL formatƒ±na d√∂n√º≈üt√ºr
            const closedAtMySQLFormat = new Date().toISOString().slice(0, 19).replace('T', ' ');
            
            await client.db.query(
                'UPDATE private_rooms SET status = ?, closed_by = ?, closed_at = ? WHERE guild_id = ? AND channel_id = ?',
                ['closed', user.id, closedAtMySQLFormat, guildID, roomId]
            );
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            if (rooms[roomId]) {
                rooms[roomId].status = 'closed';
                rooms[roomId].closedBy = user.id;
                rooms[roomId].closedAt = new Date().toISOString();
                await localDBHandler.insertData("private_rooms", `privateRoom.${guildID}.rooms`, rooms);
            }
        }
        
        // Kullanƒ±cƒ±ya bildir ve odayƒ± kapat
        await interaction.reply({ 
            content: `${emoji.done2 || '‚úÖ'} √ñzel odanƒ±z kapatƒ±lƒ±yor...`, 
            ephemeral: true 
        });
        
        // Log kanalƒ±na bilgi g√∂nder
        if (logChannel) {
            const roomName = useMySQL ? roomData.room_name : roomData.roomName;
            
            await logChannel.send({
                embeds: [{
                    title: `${emoji.trash || 'üóëÔ∏è'} √ñzel Oda Kapatƒ±ldƒ±`,
                    description: `**Oda:** ${channel.name}\n**Kapatan:** ${user} (${user.tag})\n**Oda Sahibi:** <@${ownerId}>`,
                    color: 0xED4245,
                    footer: {
                        text: `Oda ID: ${roomId}`,
                        icon_url: guild.iconURL({ dynamic: true })
                    },
                    timestamp: new Date()
                }]
            });
        }
        
        // Oda i√ßindeki √ºyeleri √ßƒ±kar
        if (channel.type === 2) { // Sesli kanal
            if (channel.members.size > 0) {
                channel.members.forEach(async (member) => {
                    try {
                        await member.voice.disconnect('√ñzel oda kapatƒ±ldƒ±');
                    } catch (error) {
                        console.error(global.hata(`√úye kanaldan √ßƒ±karƒ±lƒ±rken hata: ${error}`));
                    }
                });
            }
        }
        
        // Kanalƒ± sil
        setTimeout(async () => {
            try {
                await channel.delete(`√ñzel oda ${user.tag} tarafƒ±ndan kapatƒ±ldƒ±`);
            } catch (error) {
                console.error(global.hata(`√ñzel oda silme hatasƒ±: ${error}`));
            }
        }, 2000);
    } catch (error) {
        console.error(global.hata(`√ñzel oda kapatma hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// √ñzel oda olu≈üturma modal i≈üleme
async function handlePrivateRoomCreateModal(interaction) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Form verilerini al
        const roomName = interaction.fields.getTextInputValue('room_name');
        const userLimit = parseInt(interaction.fields.getTextInputValue('user_limit'));
        
        // Limit kontrol√º
        if (isNaN(userLimit) || userLimit < 0 || userLimit > 99) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Ge√ßersiz kullanƒ±cƒ± limiti! 0 ile 99 arasƒ±nda bir sayƒ± girmelisiniz (0 = limitsiz).`, 
                ephemeral: true 
            });
        }
        
        // Veritabanƒ± kullanƒ±labilirliƒüini kontrol et
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        // √ñzel oda ayarlarƒ±nƒ± al
        let settings;
            
        if (useMySQL) {
            const result = await client.db.select('private_room_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("private_room_settings", `privateRoom.${guildID}.settings`);
        }
        
        if (!settings) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} √ñzel oda sistemi d√ºzg√ºn yapƒ±landƒ±rƒ±lmamƒ±≈ü. L√ºtfen bir y√∂neticiye bildirin.`, 
                ephemeral: true 
            });
        }
        
        // MySQL ve LocalDB i√ßin ortak veri yapƒ±sƒ± olu≈ütur
        const categoryId = useMySQL ? settings.category_id : settings.categoryId;
        const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
        
        // Kanal izinleri ayarla
        const channelPermissions = [
            {
                id: guild.roles.everyone.id,
                deny: ['ViewChannel', 'Connect']
            },
            {
                id: user.id,
                allow: ['ViewChannel', 'Connect', 'Speak', 'Stream', 'UseVAD', 'PrioritySpeaker', 'MuteMembers', 'DeafenMembers', 'MoveMembers']
            },
            {
                id: guild.members.me.id,
                allow: ['ViewChannel', 'Connect', 'Speak', 'Stream', 'UseVAD', 'ManageChannels', 'ManageRoles']
            }
        ];
        
        // Odayƒ± olu≈ütur
        const voiceChannel = await guild.channels.create({
            name: roomName,
            type: 2, // Voice Channel
            parent: categoryId,
            userLimit: userLimit,
            permissionOverwrites: channelPermissions,
            reason: `${user.tag} tarafƒ±ndan √∂zel oda olu≈üturuldu`
        });
        
        // Oda ID'sini ve kullanƒ±cƒ± limiti veritabanƒ±na kaydet
        const roomId = voiceChannel.id;
        const createdAt = new Date();
        
        if (useMySQL) {
            // ISO datetime formatƒ±nƒ± MySQL formatƒ±na d√∂n√º≈üt√ºr
            const createdAtMySQLFormat = createdAt.toISOString().slice(0, 19).replace('T', ' ');
            
            await client.db.query(
                'INSERT INTO private_rooms (guild_id, channel_id, owner_id, room_name, user_limit, created_at, status) VALUES (?, ?, ?, ?, ?, ?, ?)',
                [guildID, roomId, user.id, roomName, userLimit, createdAtMySQLFormat, 'active']
            );
        } else {
            const roomData = {
                channelId: roomId,
                ownerId: user.id,
                roomName: roomName,
                userLimit: userLimit,
                createdAt: createdAt.toISOString(),
                status: 'active'
            };
            
            // Odalar i√ßin veri yapƒ±sƒ± var mƒ± kontrol et
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            rooms[roomId] = roomData;
            await localDBHandler.insertData("private_rooms", `privateRoom.${guildID}.rooms`, rooms);
        }
        
        // Odanƒ±n kontrol panelini olu≈ütur
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`private_room_add_${roomId}`)
                    .setLabel('Kullanƒ±cƒ± Ekle/Sil')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji(emoji.userPlus || 'üë•'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_limit_${roomId}`)
                    .setLabel('Oda Sƒ±nƒ±rƒ± Ayarla')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji(emoji.gear || '‚öôÔ∏è'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_rename_${roomId}`)
                    .setLabel('Oda ƒ∞smini Deƒüi≈ütir')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji(emoji.edit || '‚úèÔ∏è'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_close_${roomId}`)
                    .setLabel('Odayƒ± Kapat')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji(emoji.trash || 'üóëÔ∏è')
            );
        
        // Odayƒ± olu≈üturan kullanƒ±cƒ±ya bilgi mesajƒ±
        const embedColor = useMySQL ? settings.embed_color : settings.embedColor;
        
        const embed = new EmbedBuilder()
            .setTitle(`${emoji.door || 'üö™'} √ñzel Odanƒ±z Olu≈üturuldu!`)
            .setDescription(`## ${roomName}\n\nOdanƒ±zƒ± kontrol etmek i√ßin a≈üaƒüƒ±daki butonlarƒ± kullanabilirsiniz:
            
- **Kullanƒ±cƒ± Ekle/Sil**: Odanƒ±za √∂zel olarak kullanƒ±cƒ± ekleyin veya √ßƒ±karƒ±n
- **Oda Sƒ±nƒ±rƒ± Ayarla**: Odanƒ±za maksimum ka√ß ki≈üi girebileceƒüini belirleyin
- **Oda ƒ∞smini Deƒüi≈ütir**: Odanƒ±zƒ±n ismini istediƒüiniz gibi deƒüi≈ütirin
- **Odayƒ± Kapat**: Odanƒ±zƒ± kalƒ±cƒ± olarak silin`)
            .setColor(embedColor ? parseInt(embedColor.replace('#', ''), 16) : 0x5768ea)
            .setFooter({
                text: `${guild.name} ‚Ä¢ √ñzel Oda Sistemi`,
                iconURL: guild.iconURL({ dynamic: true })
            })
            .setTimestamp();
        
            await interaction.reply({ 
                embeds: [embed],
                components: [row],
                ephemeral: true
            });
            
        
        // Log kanalƒ±na bilgi mesajƒ±
        const logChannel = guild.channels.cache.get(logChannelId);
        if (logChannel) {
            logChannel.send({
                embeds: [{
                    title: `${emoji.door || 'üö™'} Yeni √ñzel Oda Olu≈üturuldu`,
                    description: `**Oda:** ${voiceChannel}\n**Sahibi:** ${user} (${user.tag})\n**Kullanƒ±cƒ± Limiti:** ${userLimit === 0 ? 'Limitsiz' : userLimit}`,
                    color: embedColor ? parseInt(embedColor.replace('#', ''), 16) : 0x5768ea,
                    footer: {
                        text: `Oda ID: ${roomId}`,
                        icon_url: guild.iconURL({ dynamic: true })
                    },
                    timestamp: new Date()
                }]
            });
        }
    } catch (error) {
        console.error(global.hata(`√ñzel oda olu≈üturma i≈üleme hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `‚ùå √ñzel oda olu≈üturulurken bir hata olu≈ütu: ${error.message}`,
            ephemeral: true 
        });
    }
}

// √ñzel odaya kullanƒ±cƒ± ekleme/silme butonu i≈üleme
async function handlePrivateRoomAddUser(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Oda bilgisini veritabanƒ±ndan al
        let roomData;
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            const result = await client.db.select('private_rooms', { 
                guild_id: guildID, 
                channel_id: roomId,
                status: 'active'
            });
            roomData = result && result.length > 0 ? result[0] : null;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            roomData = rooms[roomId];
        }
        
        if (!roomData) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu oda bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Kullanƒ±cƒ± oda sahibi mi kontrol et
        const ownerId = useMySQL ? roomData.owner_id : roomData.ownerId;
        
        if (user.id !== ownerId) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu odanƒ±n sahibi siz deƒüilsiniz!`, 
                ephemeral: true 
            });
        }
        
        // Modal olu≈ütur
        const modal = new ModalBuilder()
            .setCustomId(`modal_private_room_add_${roomId}`)
            .setTitle('Kullanƒ±cƒ± Ekle veya Sil');
            
        // Kullanƒ±cƒ± ID giri≈ü alanƒ±
        const userIdInput = new TextInputBuilder()
            .setCustomId('user_id')
            .setLabel('Kullanƒ±cƒ± ID')
            .setPlaceholder('Eklemek veya silmek istediƒüiniz kullanƒ±cƒ±nƒ±n ID\'sini girin')
            .setStyle(TextInputStyle.Short)
            .setRequired(true);
            
        // ƒ∞≈ülem se√ßimi
        const actionInput = new TextInputBuilder()
            .setCustomId('action')
            .setLabel('ƒ∞≈ülem (ekle/sil)')
            .setPlaceholder('ekle veya sil yazƒ±n')
            .setStyle(TextInputStyle.Short)
            .setRequired(true);
            
        // Action row'larƒ± olu≈ütur
        const firstRow = new ActionRowBuilder().addComponents(userIdInput);
        const secondRow = new ActionRowBuilder().addComponents(actionInput);
        
        // Modal'a action row'larƒ± ekle
        modal.addComponents(firstRow, secondRow);
        
        // Modal'ƒ± g√∂ster
        await interaction.showModal(modal);
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda kullanƒ±cƒ± ekleme hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// Oda sƒ±nƒ±rƒ±nƒ± ayarlama butonu i≈üleme
async function handlePrivateRoomLimit(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Oda bilgisini veritabanƒ±ndan al
        let roomData;
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            const result = await client.db.select('private_rooms', { 
                guild_id: guildID, 
                channel_id: roomId,
                status: 'active'
            });
            roomData = result && result.length > 0 ? result[0] : null;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            roomData = rooms[roomId];
        }
        
        if (!roomData) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu oda bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Kullanƒ±cƒ± oda sahibi mi kontrol et
        const ownerId = useMySQL ? roomData.owner_id : roomData.ownerId;
        
        if (user.id !== ownerId) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu odanƒ±n sahibi siz deƒüilsiniz!`, 
                ephemeral: true 
            });
        }
        
        // Modal olu≈ütur
        const modal = new ModalBuilder()
            .setCustomId(`modal_private_room_limit_${roomId}`)
            .setTitle('Oda Kullanƒ±cƒ± Limiti');
            
        // Limit giri≈ü alanƒ±
        const limitInput = new TextInputBuilder()
            .setCustomId('user_limit')
            .setLabel('Kullanƒ±cƒ± Limiti')
            .setPlaceholder('Maksimum ka√ß ki≈üi girebilir? (0-99, 0 = limitsiz)')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMinLength(1)
            .setMaxLength(2);
            
        // Action row olu≈ütur
        const firstRow = new ActionRowBuilder().addComponents(limitInput);
        
        // Modal'a action row'u ekle
        modal.addComponents(firstRow);
        
        // Modal'ƒ± g√∂ster
        await interaction.showModal(modal);
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda sƒ±nƒ±rƒ± ayarlama hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// √ñzel oda olu≈üturma modal i≈üleme
async function handlePrivateRoomCreateModal(interaction) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Form verilerini al
        const roomName = interaction.fields.getTextInputValue('room_name');
        const userLimit = parseInt(interaction.fields.getTextInputValue('user_limit'));
        
        // Limit kontrol√º
        if (isNaN(userLimit) || userLimit < 0 || userLimit > 99) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Ge√ßersiz kullanƒ±cƒ± limiti! 0 ile 99 arasƒ±nda bir sayƒ± girmelisiniz (0 = limitsiz).`, 
                ephemeral: true 
            });
        }
        
        // Veritabanƒ± kullanƒ±labilirliƒüini kontrol et
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        // √ñzel oda ayarlarƒ±nƒ± al
        let settings;
            
        if (useMySQL) {
            const result = await client.db.select('private_room_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("private_room_settings", `privateRoom.${guildID}.settings`);
        }
        
        if (!settings) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} √ñzel oda sistemi d√ºzg√ºn yapƒ±landƒ±rƒ±lmamƒ±≈ü. L√ºtfen bir y√∂neticiye bildirin.`, 
                ephemeral: true 
            });
        }
        
        // MySQL ve LocalDB i√ßin ortak veri yapƒ±sƒ± olu≈ütur
        const categoryId = useMySQL ? settings.category_id : settings.categoryId;
        const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
        
        // Kanal izinleri ayarla
        const channelPermissions = [
            {
                id: guild.roles.everyone.id,
                deny: ['ViewChannel', 'Connect']
            },
            {
                id: user.id,
                allow: ['ViewChannel', 'Connect', 'Speak', 'Stream', 'UseVAD', 'PrioritySpeaker', 'MuteMembers', 'DeafenMembers', 'MoveMembers']
            },
            {
                id: guild.members.me.id,
                allow: ['ViewChannel', 'Connect', 'Speak', 'Stream', 'UseVAD', 'ManageChannels', 'ManageRoles']
            }
        ];
        
        // Odayƒ± olu≈ütur
        const voiceChannel = await guild.channels.create({
            name: roomName,
            type: 2, // Voice Channel
            parent: categoryId,
            userLimit: userLimit,
            permissionOverwrites: channelPermissions,
            reason: `${user.tag} tarafƒ±ndan √∂zel oda olu≈üturuldu`
        });
        
        // Oda ID'sini ve kullanƒ±cƒ± limiti veritabanƒ±na kaydet
        const roomId = voiceChannel.id;
        const createdAt = new Date();
        
        if (useMySQL) {
            // ISO datetime formatƒ±nƒ± MySQL formatƒ±na d√∂n√º≈üt√ºr
            const createdAtMySQLFormat = createdAt.toISOString().slice(0, 19).replace('T', ' ');
            
            await client.db.query(
                'INSERT INTO private_rooms (guild_id, channel_id, owner_id, room_name, user_limit, created_at, status) VALUES (?, ?, ?, ?, ?, ?, ?)',
                [guildID, roomId, user.id, roomName, userLimit, createdAtMySQLFormat, 'active']
            );
        } else {
            const roomData = {
                channelId: roomId,
                ownerId: user.id,
                roomName: roomName,
                userLimit: userLimit,
                createdAt: createdAt.toISOString(),
                status: 'active'
            };
            
            // Odalar i√ßin veri yapƒ±sƒ± var mƒ± kontrol et
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            rooms[roomId] = roomData;
            await localDBHandler.insertData("private_rooms", `privateRoom.${guildID}.rooms`, rooms);
        }
        
        // Odanƒ±n kontrol panelini olu≈ütur
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`private_room_add_${roomId}`)
                    .setLabel('Kullanƒ±cƒ± Ekle/Sil')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji(emoji.userPlus || 'üë•'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_limit_${roomId}`)
                    .setLabel('Oda Sƒ±nƒ±rƒ± Ayarla')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji(emoji.gear || '‚öôÔ∏è'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_rename_${roomId}`)
                    .setLabel('Oda ƒ∞smini Deƒüi≈ütir')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji(emoji.edit || '‚úèÔ∏è'),
                    
                new ButtonBuilder()
                    .setCustomId(`private_room_close_${roomId}`)
                    .setLabel('Odayƒ± Kapat')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji(emoji.trash || 'üóëÔ∏è')
            );
        
        // Odayƒ± olu≈üturan kullanƒ±cƒ±ya bilgi mesajƒ±
        const embedColor = useMySQL ? settings.embed_color : settings.embedColor;
        
        const embed = new EmbedBuilder()
            .setTitle(`${emoji.door || 'üö™'} √ñzel Odanƒ±z Olu≈üturuldu!`)
            .setDescription(`## ${roomName}\n\nOdanƒ±zƒ± kontrol etmek i√ßin a≈üaƒüƒ±daki butonlarƒ± kullanabilirsiniz:
            
- **Kullanƒ±cƒ± Ekle/Sil**: Odanƒ±za √∂zel olarak kullanƒ±cƒ± ekleyin veya √ßƒ±karƒ±n
- **Oda Sƒ±nƒ±rƒ± Ayarla**: Odanƒ±za maksimum ka√ß ki≈üi girebileceƒüini belirleyin
- **Oda ƒ∞smini Deƒüi≈ütir**: Odanƒ±zƒ±n ismini istediƒüiniz gibi deƒüi≈ütirin
- **Odayƒ± Kapat**: Odanƒ±zƒ± kalƒ±cƒ± olarak silin`)
            .setColor(embedColor ? parseInt(embedColor.replace('#', ''), 16) : 0x5768ea)
            .setFooter({
                text: `${guild.name} ‚Ä¢ √ñzel Oda Sistemi`,
                iconURL: guild.iconURL({ dynamic: true })
            })
            .setTimestamp();
        
        await interaction.reply({ 
            embeds: [embed],
            components: [row],
            ephemeral: true
        });
        
        // Log kanalƒ±na bilgi mesajƒ±
        const logChannel = guild.channels.cache.get(logChannelId);
        if (logChannel) {
            logChannel.send({
                embeds: [{
                    title: `${emoji.door || 'üö™'} Yeni √ñzel Oda Olu≈üturuldu`,
                    description: `**Oda:** ${voiceChannel}\n**Sahibi:** ${user} (${user.tag})\n**Kullanƒ±cƒ± Limiti:** ${userLimit === 0 ? 'Limitsiz' : userLimit}`,
                    color: embedColor ? parseInt(embedColor.replace('#', ''), 16) : 0x5768ea,
                    footer: {
                        text: `Oda ID: ${roomId}`,
                        icon_url: guild.iconURL({ dynamic: true })
                    },
                    timestamp: new Date()
                }]
            });
        }
    } catch (error) {
        console.error(global.hata(`√ñzel oda olu≈üturma i≈üleme hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `‚ùå √ñzel oda olu≈üturulurken bir hata olu≈ütu: ${error.message}`,
            ephemeral: true 
        });
    }
}

// Oda ismini deƒüi≈ütirme butonu i≈üleme
async function handlePrivateRoomRename(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Oda bilgisini veritabanƒ±ndan al
        let roomData;
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            const result = await client.db.select('private_rooms', { 
                guild_id: guildID, 
                channel_id: roomId,
                status: 'active'
            });
            roomData = result && result.length > 0 ? result[0] : null;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            roomData = rooms[roomId];
        }
        
        if (!roomData) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu oda bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Kullanƒ±cƒ± oda sahibi mi kontrol et
        const ownerId = useMySQL ? roomData.owner_id : roomData.ownerId;
        
        if (user.id !== ownerId) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu odanƒ±n sahibi siz deƒüilsiniz!`, 
                ephemeral: true 
            });
        }
        
        // Modal olu≈ütur
        const modal = new ModalBuilder()
            .setCustomId(`modal_private_room_rename_${roomId}`)
            .setTitle('Oda ƒ∞smini Deƒüi≈ütir');
            
        // ƒ∞sim giri≈ü alanƒ±
        const nameInput = new TextInputBuilder()
            .setCustomId('room_name')
            .setLabel('Yeni Oda ƒ∞smi')
            .setPlaceholder('Odanƒ±zƒ±n yeni ismini girin')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMinLength(2)
            .setMaxLength(32);
            
        // Action row olu≈ütur
        const firstRow = new ActionRowBuilder().addComponents(nameInput);
        
        // Modal'a action row'u ekle
        modal.addComponents(firstRow);
        
        // Modal'ƒ± g√∂ster
        await interaction.showModal(modal);
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda isim deƒüi≈ütirme hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// Oda ismi deƒüi≈ütirme modal i≈üleme
async function handlePrivateRoomRenameModal(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Form verilerini al
        const newRoomName = interaction.fields.getTextInputValue('room_name');
        
        // Kanalƒ± kontrol et
        const channel = guild.channels.cache.get(roomId);
        if (!channel) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu kanal bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Oda ismini g√ºncelle
        await channel.edit({
            name: newRoomName
        });
        
        // Veritabanƒ± bilgilerini g√ºncelle
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            await client.db.query(
                'UPDATE private_rooms SET room_name = ? WHERE guild_id = ? AND channel_id = ?',
                [newRoomName, guildID, roomId]
            );
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            if (rooms[roomId]) {
                rooms[roomId].roomName = newRoomName;
                await localDBHandler.insertData("private_rooms", `privateRoom.${guildID}.rooms`, rooms);
            }
        }
        
        return interaction.reply({ 
            content: `${emoji.done2 || '‚úÖ'} √ñzel odanƒ±zƒ±n ismi ba≈üarƒ±yla "${newRoomName}" olarak deƒüi≈ütirildi!`, 
            ephemeral: true 
        });
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda isim deƒüi≈ütirme modal hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// Odayƒ± kapatma butonu i≈üleme
async function handlePrivateRoomClose(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Oda bilgisini veritabanƒ±ndan al
        let roomData;
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            const result = await client.db.select('private_rooms', { 
                guild_id: guildID, 
                channel_id: roomId,
                status: 'active'
            });
            roomData = result && result.length > 0 ? result[0] : null;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            roomData = rooms[roomId];
        }
        
        if (!roomData) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu oda bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Kullanƒ±cƒ± oda sahibi mi kontrol et
        const ownerId = useMySQL ? roomData.owner_id : roomData.ownerId;
        
        if (user.id !== ownerId && !interaction.member.permissions.has('Administrator')) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu odayƒ± kapatmak i√ßin oda sahibi veya y√∂netici olmanƒ±z gerekiyor!`, 
                ephemeral: true 
            });
        }
        
        // Kanalƒ± kontrol et
        const channel = guild.channels.cache.get(roomId);
        if (!channel) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu kanal bulunamadƒ± veya zaten silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // √ñzel oda ayarlarƒ±nƒ± al
        let settings;
        if (useMySQL) {
            const result = await client.db.select('private_room_settings', { guild_id: guildID });
            settings = result && result.length > 0 ? result[0] : null;
        } else {
            settings = await localDBHandler.getData("private_room_settings", `privateRoom.${guildID}.settings`);
        }
        
        // Log kanalƒ±nƒ± bul
        let logChannel;
        if (settings) {
            const logChannelId = useMySQL ? settings.log_channel_id : settings.logChannelId;
            logChannel = guild.channels.cache.get(logChannelId);
        }
        
        // Veritabanƒ± bilgilerini g√ºncelle
        if (useMySQL) {
            // Instead of updating, delete the room entry completely from the database
            await client.db.query(
            'DELETE FROM private_rooms WHERE guild_id = ? AND channel_id = ?',
            [guildID, roomId]
            );
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            if (rooms[roomId]) {
            // Remove the room entry completely from the local database
            delete rooms[roomId];
            await localDBHandler.insertData("private_rooms", `privateRoom.${guildID}.rooms`, rooms);
            }
        }
        
        // Kullanƒ±cƒ±ya bildir ve odayƒ± kapat
        await interaction.reply({ 
            content: `${emoji.done2 || '‚úÖ'} √ñzel odanƒ±z kapatƒ±lƒ±yor...`, 
            ephemeral: true 
        });
        
        // Log kanalƒ±na bilgi g√∂nder
        if (logChannel) {
            const roomName = useMySQL ? roomData.room_name : roomData.roomName;
            
            await logChannel.send({
                embeds: [{
                    title: `${emoji.trash || 'üóëÔ∏è'} √ñzel Oda Kapatƒ±ldƒ±`,
                    description: `**Oda:** ${channel.name}\n**Kapatan:** ${user} (${user.tag})\n**Oda Sahibi:** <@${ownerId}>`,
                    color: 0xED4245,
                    footer: {
                        text: `Oda ID: ${roomId}`,
                        icon_url: guild.iconURL({ dynamic: true })
                    },
                    timestamp: new Date()
                }]
            });
        }
        
        // Oda i√ßindeki √ºyeleri √ßƒ±kar
        if (channel.type === 2) { // Sesli kanal
            if (channel.members.size > 0) {
                channel.members.forEach(async (member) => {
                    try {
                        await member.voice.disconnect('√ñzel oda kapatƒ±ldƒ±');
                    } catch (error) {
                        console.error(global.hata(`√úye kanaldan √ßƒ±karƒ±lƒ±rken hata: ${error}`));
                    }
                });
            }
        }
        
        // Kanalƒ± sil
        setTimeout(async () => {
            try {
                await channel.delete(`√ñzel oda ${user.tag} tarafƒ±ndan kapatƒ±ldƒ±`);
            } catch (error) {
                console.error(global.hata(`√ñzel oda silme hatasƒ±: ${error}`));
            }
        }, 2000);
    } catch (error) {
        console.error(global.hata(`√ñzel oda kapatma hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// √ñzel odaya kullanƒ±cƒ± ekleme/silme modal i≈üleme
async function handlePrivateRoomAddUserModal(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Form verilerini al
        const targetUserId = interaction.fields.getTextInputValue('user_id');
        const action = interaction.fields.getTextInputValue('action').toLowerCase();
        
        // Kullanƒ±cƒ± ID kontrol√º
        if (isNaN(targetUserId) || targetUserId.length < 17 || targetUserId.length > 19) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Ge√ßersiz kullanƒ±cƒ± ID'si!`, 
                ephemeral: true 
            });
        }
        
        // Oda bilgisini veritabanƒ±ndan al
        let roomData;
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            const result = await client.db.select('private_rooms', { 
                guild_id: guildID, 
                channel_id: roomId,
                status: 'active'
            });
            roomData = result && result.length > 0 ? result[0] : null;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            roomData = rooms[roomId];
        }
        
        if (!roomData) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu oda bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Kullanƒ±cƒ± oda sahibi mi kontrol et
        const ownerId = useMySQL ? roomData.owner_id : roomData.ownerId;
        
        if (user.id !== ownerId) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu odanƒ±n sahibi siz deƒüilsiniz!`, 
                ephemeral: true 
            });
        }
        
        // Kanalƒ± kontrol et
        const channel = guild.channels.cache.get(roomId);
        if (!channel) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu kanal bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Hedef kullanƒ±cƒ±yƒ± al
        const targetUser = await client.users.fetch(targetUserId).catch(() => null);
        if (!targetUser) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Kullanƒ±cƒ± bulunamadƒ±!`, 
                ephemeral: true 
            });
        }
        
        // ƒ∞≈ülem t√ºr√ºne g√∂re ekle veya sil
        if (action === 'ekle') {
            await channel.permissionOverwrites.edit(targetUserId, { 
                ViewChannel: true, 
                Connect: true, 
                Speak: true 
            });
            
            return interaction.reply({ 
                content: `${emoji.done2 || '‚úÖ'} Kullanƒ±cƒ± ba≈üarƒ±yla eklendi!`, 
                ephemeral: true 
            });
        } else if (action === 'sil') {
            await channel.permissionOverwrites.delete(targetUserId);
            
            return interaction.reply({ 
                content: `${emoji.done2 || '‚úÖ'} Kullanƒ±cƒ± ba≈üarƒ±yla silindi!`, 
                ephemeral: true 
            });
        } else {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Ge√ßersiz i≈ülem! "ekle" veya "sil" yazmalƒ±sƒ±nƒ±z.`, 
                ephemeral: true 
            });
        }
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda kullanƒ±cƒ± ekleme/silme modal hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}

// Oda sƒ±nƒ±rƒ±nƒ± ayarlama modal i≈üleme
async function handlePrivateRoomLimitModal(interaction, roomId) {
    try {
        const { client, guild, user } = interaction;
        const guildID = guild.id;
        const embedHandler = require('../util/embedHandler')(client);
        const emoji = require('../util/emoji');
        const { database_type } = require('../config.json');
        const localDBHandler = require('../util/localDBHandler');
        
        // Form verilerini al
        const userLimit = parseInt(interaction.fields.getTextInputValue('user_limit'));
        
        // Limit kontrol√º
        if (isNaN(userLimit) || userLimit < 0 || userLimit > 99) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Ge√ßersiz kullanƒ±cƒ± limiti! 0 ile 99 arasƒ±nda bir sayƒ± girmelisiniz (0 = limitsiz).`, 
                ephemeral: true 
            });
        }
        
        // Oda bilgisini veritabanƒ±ndan al
        let roomData;
        const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
        
        if (useMySQL) {
            const result = await client.db.select('private_rooms', { 
                guild_id: guildID, 
                channel_id: roomId,
                status: 'active'
            });
            roomData = result && result.length > 0 ? result[0] : null;
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            roomData = rooms[roomId];
        }
        
        if (!roomData) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu oda bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Kullanƒ±cƒ± oda sahibi mi kontrol et
        const ownerId = useMySQL ? roomData.owner_id : roomData.ownerId;
        
        if (user.id !== ownerId) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu odanƒ±n sahibi siz deƒüilsiniz!`, 
                ephemeral: true 
            });
        }
        
        // Kanalƒ± kontrol et
        const channel = guild.channels.cache.get(roomId);
        if (!channel) {
            return interaction.reply({ 
                content: `${emoji.closed || '‚ùå'} Bu kanal bulunamadƒ± veya silinmi≈ü!`, 
                ephemeral: true 
            });
        }
        
        // Oda limitini g√ºncelle
        await channel.edit({
            userLimit: userLimit
        });
        
        // Veritabanƒ± bilgilerini g√ºncelle
        if (useMySQL) {
            await client.db.query(
                'UPDATE private_rooms SET user_limit = ? WHERE guild_id = ? AND channel_id = ?',
                [userLimit, guildID, roomId]
            );
        } else {
            const rooms = await localDBHandler.getData("private_rooms", `privateRoom.${guildID}.rooms`) || {};
            if (rooms[roomId]) {
                rooms[roomId].userLimit = userLimit;
                await localDBHandler.insertData("private_rooms", `privateRoom.${guildID}.rooms`, rooms);
            }
        }
        
        return interaction.reply({ 
            content: `${emoji.done2 || '‚úÖ'} Oda kullanƒ±cƒ± limiti ba≈üarƒ±yla ${userLimit === 0 ? 'limitsiz' : userLimit} olarak ayarlandƒ±!`, 
            ephemeral: true 
        });
        
    } catch (error) {
        console.error(global.hata(`√ñzel oda sƒ±nƒ±rƒ± ayarlama modal hatasƒ±: ${error}`));
        return interaction.reply({ 
            content: `${emoji.closed || '‚ùå'} ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu!`, 
            ephemeral: true 
        });
    }
}
