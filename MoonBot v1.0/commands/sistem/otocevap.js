const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');
const emoji = require('../../util/emoji');
const { database_type } = require('../../config.json');
const fs = require('fs');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('otocevap')
        .setDescription('Otomatik cevap sistemini y√∂netir')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageMessages)
        .addSubcommand(subcommand =>
            subcommand
                .setName('ekle')
                .setDescription('Yeni bir otomatik cevap ekler')
                .addStringOption(option =>
                    option.setName('tetikleyici')
                        .setDescription('Botun tepki vereceƒüi kelime veya c√ºmle')
                        .setRequired(true))
                .addStringOption(option =>
                    option.setName('yanƒ±t')
                        .setDescription('Botun vereceƒüi cevap')
                        .setRequired(true))
                .addBooleanOption(option =>
                    option.setName('embed')
                        .setDescription('Yanƒ±tƒ±n embed olarak g√∂nderilip g√∂nderilmeyeceƒüi')
                        .setRequired(false))
                .addStringOption(option =>
                    option.setName('renk')
                        .setDescription('Embed rengi (HEX formatƒ±nda, √∂rn: #5768ea)')
                        .setRequired(false)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('sil')
                .setDescription('Bir otomatik cevabƒ± siler')
                .addStringOption(option =>
                    option.setName('tetikleyici')
                        .setDescription('Silinecek otomatik cevabƒ±n tetikleyicisi')
                        .setRequired(true)
                        .setAutocomplete(true)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('liste')
                .setDescription('Sunucudaki t√ºm otomatik cevaplarƒ± listeler'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('bilgi')
                .setDescription('Belirli bir otomatik cevap hakkƒ±nda bilgi verir')
                .addStringOption(option =>
                    option.setName('tetikleyici')
                        .setDescription('Bilgi alƒ±nacak otomatik cevabƒ±n tetikleyicisi')
                        .setRequired(true)
                        .setAutocomplete(true))),

    async autocomplete(interaction) {
        const { options, client, guild } = interaction;
        const focusedValue = options.getFocused().toLowerCase();
        
        try {
            // Sunucudaki otomatik cevap tetikleyicilerini al
            const triggers = await getAutoResponseTriggers(client, guild.id);
            
            // Filtreleme yap
            const filtered = triggers.filter(trigger => 
                trigger.toLowerCase().includes(focusedValue)
            ).slice(0, 25);
            
            await interaction.respond(
                filtered.map(trigger => ({ name: trigger, value: trigger }))
            );
        } catch (error) {
            console.error(global.hata(`Otocevap autocomplete hatasƒ±: ${error.message}`));
            await interaction.respond([]);
        }
    },

    async execute(interaction) {
        try {
            const { options, client, guild } = interaction;
            const embedHandler = require('../../util/embedHandler')(client);
            const subcommand = options.getSubcommand();
            const guildID = guild.id;
            
            // Veritabanƒ± kullanƒ±labilirliƒüini kontrol et
            const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
            
            if (subcommand === 'ekle') {
                const trigger = options.getString('tetikleyici');
                const response = options.getString('yanƒ±t');
                const useEmbed = options.getBoolean('embed') || false;
                let embedColor = options.getString('renk') || '#5768ea';
                
                // Renk formatƒ± kontrol√º
                if (useEmbed) {
                    const colorRegex = /^#[0-9A-Fa-f]{6}$/;
                    if (!colorRegex.test(embedColor)) {
                        const embed = embedHandler.errorEmbed(
                            `> ${emoji.close} Hata:`,
                            `> \`Ge√ßersiz renk formatƒ±. HEX formatƒ±nda olmalƒ±dƒ±r. √ñrn: #5768ea\``
                        );
                        return interaction.reply({ embeds: [embed], ephemeral: true });
                    }
                }
                
                // Eƒüer tetikleyici zaten varsa kontrol et
                const exists = await checkTriggerExists(client, guildID, trigger);
                if (exists) {
                    const embed = embedHandler.errorEmbed(
                        `> ${emoji.close} Hata:`,
                        `> \`'${trigger}' tetikleyicisi zaten kullanƒ±mda! √ñnce mevcut olanƒ± silin veya farklƒ± bir tetikleyici se√ßin.\``
                    );
                    return interaction.reply({ embeds: [embed], ephemeral: true });
                }
                
                if (useMySQL) {
                    try {
                        await client.db.insert('auto_responses', {
                            guild_id: guildID,
                            trigger_text: trigger,
                            response_text: response,
                            use_embed: useEmbed ? 1 : 0,
                            embed_color: embedColor
                        });
                    } catch (dbError) {
                        console.error(global.hata(`MySQL kayƒ±t hatasƒ±: ${dbError.message}`));
                        // MySQL hatasƒ± durumunda yerel veritabanƒ±na kaydet
                    }
                } else {
                    // Yerel veritabanƒ±na kaydet
                    saveToLocalDB(client.localDB, guildID, trigger, response, useEmbed, embedColor);
                }
                
                const embed = embedHandler.successEmbed(
                    `> ${emoji.done} Ba≈üarƒ±lƒ±!`,
                    `> \`'${trigger}' tetikleyicili otomatik cevap eklendi.\`` +
                    `${useEmbed ? '\n> \`Yanƒ±t embed olarak g√∂nderilecek.\`' : ''}`
                );
                
                return interaction.reply({ embeds: [embed] });
                
            } else if (subcommand === 'sil') {
                const trigger = options.getString('tetikleyici');
                
                // Tetikleyicinin var olup olmadƒ±ƒüƒ±nƒ± kontrol et
                const exists = await checkTriggerExists(client, guildID, trigger);
                if (!exists) {
                    const embed = embedHandler.errorEmbed(
                        `> ${emoji.close} Hata:`,
                        `> \`'${trigger}' tetikleyicili bir otomatik cevap bulunamadƒ±.\``
                    );
                    return interaction.reply({ embeds: [embed], ephemeral: true });
                }
                
                if (useMySQL) {
                    try {
                        await client.db.delete('auto_responses', { 
                            guild_id: guildID,
                            trigger_text: trigger
                        });
                    } catch (dbError) {
                        console.error(global.hata(`MySQL silme hatasƒ±: ${dbError.message}`));
                    }
                } else {
                    deleteFromLocalDB(client.localDB, guildID, trigger);
                }
                
                // Her durumda yerel veritabanƒ±ndan da sil
                
                
                const embed = embedHandler.successEmbed(
                    `> ${emoji.done} Ba≈üarƒ±lƒ±!`,
                    `> \`'${trigger}' tetikleyicili otomatik cevap silindi.\``
                );
                
                return interaction.reply({ embeds: [embed] });
                
            } else if (subcommand === 'liste') {
                // Sunucunun t√ºm otomatik cevaplarƒ±nƒ± al
                const responses = await getAutoResponses(client, guildID);
                
                if (responses.length === 0) {
                    const embed = embedHandler.infoEmbed(
                        `> ${emoji.info} Bilgi:`,
                        `> \`Bu sunucuda hi√ß otomatik cevap tanƒ±mlanmamƒ±≈ü.\``
                    );
                    return interaction.reply({ embeds: [embed], ephemeral: true });
                }
                
                // Tepkileri al ve listele
                const embed = embedHandler.infoEmbed(
                    `> ${emoji.info} Otomatik Cevaplar`,
                    `> \`Bu sunucuda ${responses.length} adet otomatik cevap bulunuyor.\``
                );
                
                // Her tetikleyiciyi ekle (maksimum 25 adet g√∂ster)
                const maxToShow = Math.min(responses.length, 25);
                for (let i = 0; i < maxToShow; i++) {
                    embed.addFields({
                        name: `${i+1}. ${responses[i].trigger}`,
                        value: `${responses[i].useEmbed ? 'üìù Embed' : 'üí¨ Normal'}`
                    });
                }
                
                if (responses.length > maxToShow) {
                    embed.addFields({
                        name: `... ve ${responses.length - maxToShow} daha`,
                        value: `T√ºm listeyi g√∂rmek i√ßin daha spesifik bir komut eklenecek.`
                    });
                }
                
                return interaction.reply({ embeds: [embed] });
                
            } else if (subcommand === 'bilgi') {
                const trigger = options.getString('tetikleyici');
                
                // Belirtilen tetikleyicinin detaylarƒ±nƒ± al
                const response = await getAutoResponseDetail(client, guildID, trigger);
                
                if (!response) {
                    const embed = embedHandler.errorEmbed(
                        `> ${emoji.close} Hata:`,
                        `> \`'${trigger}' tetikleyicili bir otomatik cevap bulunamadƒ±.\``
                    );
                    return interaction.reply({ embeds: [embed], ephemeral: true });
                }
                
                const embed = embedHandler.infoEmbed(
                    `> ${emoji.info} Otomatik Cevap Detayƒ±`,
                    `> \`Tetikleyici: ${response.trigger}\``
                )
                .addFields(
                    { name: 'Yanƒ±t', value: response.response.length > 1024 ? 
                        response.response.substring(0, 1021) + '...' : response.response },
                    { name: 'Yanƒ±t Tipi', value: response.useEmbed ? 'Embed' : 'Normal Mesaj', inline: true }
                );
                
                if (response.useEmbed) {
                    embed.addFields({ name: 'Embed Rengi', value: response.embedColor, inline: true });
                }
                
                return interaction.reply({ embeds: [embed] });
            }
            
        } catch (error) {
            console.error(global.hata(`Otocevap komutu hatasƒ±: ${error.message}`));
            
            // Hata durumunda embedHandler olu≈ütur
            let embedHandler;
            try {
                embedHandler = require('../../util/embedHandler')(interaction.client);
            } catch (embErr) {
                // Fallback embed yanƒ±tƒ±
                return interaction.reply({ 
                    content: "Bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin.", 
                    ephemeral: true 
                });
            }
            
            const errorEmbed = embedHandler.errorEmbed(
                `> ${emoji.close} Hata:`,
                `> \`Bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin.\``
            );
            
            // Ensure interaction is replied to even if an error occurs
            if (!interaction.replied && !interaction.deferred) {
                return interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            } else {
                return interaction.followUp({ embeds: [errorEmbed], ephemeral: true });
            }
        }
    },
};

// LocalDB'ye otomatik cevap kaydetme
function saveToLocalDB(localDB, guildID, trigger, response, useEmbed, embedColor) {
    const key = `${guildID}_${trigger.toLowerCase()}`;
    const data = {
        trigger: trigger,
        response: response,
        useEmbed: useEmbed,
        embedColor: embedColor
    };
    localDB.insertData('otocevap', key, data);
}

// LocalDB'den otomatik cevap silme
function deleteFromLocalDB(localDB, guildID, trigger) {
    const key = `${guildID}_${trigger.toLowerCase()}`;
    localDB.deleteData('otocevap', key);
}

// Tetikleyicinin var olup olmadƒ±ƒüƒ±nƒ± kontrol et
async function checkTriggerExists(client, guildID, trigger) {
    const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
    
    if (useMySQL) {
        try {
            const results = await client.db.select('auto_responses', { 
                guild_id: guildID,
                trigger_text: trigger
            });
            return results && results.length > 0;
        } catch (err) {
            console.error(global.hata(`MySQL sorgu hatasƒ±: ${err.message}`));
        }
    } else {
        const key = `${guildID}_${trigger.toLowerCase()}`;
        const data = client.localDB.getData("otocevap", key);
        return data !== null;
    }   
}

// Sunucunun t√ºm otomatik cevaplarƒ±nƒ± al
async function getAutoResponses(client, guildID) {
    const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
    let responses = [];
    
    if (useMySQL) {
        try {
            const results = await client.db.select('auto_responses', { guild_id: guildID });
            if (results && results.length > 0) {
                responses = results.map(row => ({
                    trigger: row.trigger_text,
                    response: row.response_text,
                    useEmbed: row.use_embed === 1,
                    embedColor: row.embed_color
                }));
            }
        } catch (err) {
            console.error(global.hata(`MySQL sorgu hatasƒ±: ${err.message}`));
        }
    } else {
        try {
            const dbFilePath = client.localDB.getDBFilePath('otocevap');
            if (fs.existsSync(dbFilePath)) {
                const fileContent = fs.readFileSync(dbFilePath, "utf-8");
                if (fileContent) {
                    const dbData = JSON.parse(fileContent);
                    
                    // Sunucuya ait kayƒ±tlarƒ± filtrele
                    const prefix = `${guildID}_`;
                    responses = Object.keys(dbData)
                        .filter(key => key.startsWith(prefix))
                        .map(key => dbData[key]);
                }
            }
        } catch (err) {
            console.error(global.hata(`LocalDB okuma hatasƒ±: ${err.message}`));
        }
    }
    return responses;
}

// Otomatik cevap tetikleyicilerini al
async function getAutoResponseTriggers(client, guildID) {
    const responses = await getAutoResponses(client, guildID);
    return responses.map(response => response.trigger);
}

// Belirli bir tetikleyicinin detaylarƒ±nƒ± al
async function getAutoResponseDetail(client, guildID, trigger) {
    const useMySQL = database_type === 'mysql' && client.db && client.db.isConnected;
    
    if (useMySQL) {
        try {
            const results = await client.db.select('auto_responses', { 
                guild_id: guildID,
                trigger_text: trigger
            });
            
            if (results && results.length > 0) {
                return {
                    trigger: results[0].trigger_text,
                    response: results[0].response_text,
                    useEmbed: results[0].use_embed === 1,
                    embedColor: results[0].embed_color
                };
            }
        } catch (err) {
            console.error(global.hata(`MySQL sorgu hatasƒ±: ${err.message}`));
        }
    } else {
        const key = `${guildID}_${trigger.toLowerCase()}`;
        const data = client.localDB.getData("otocevap", key);
        return data;
    }
    

}
